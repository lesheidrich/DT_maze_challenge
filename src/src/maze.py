import xml.etree.ElementTree as ET
from typing import List, Tuple


class Maze:
    """
    Reads XML data to interpret and construct 2D str maze along with metadata.
    """
    def __init__(self, mazeXML: ET.Element):
        self.root = ET.fromstring(mazeXML)
        self.level = int(self.root.find("Level").text)
        self.start = (
            int(self.root.find("StartPoint/Row").text) - 1,
            int(self.root.find("StartPoint/Column").text) - 1
        )
        self.escape = (
            int(self.root.find("EscapePoint/Row").text) - 1,
            int(self.root.find("EscapePoint/Column").text) - 1
        )
        self.walls = self._get_element("Wall")
        self.traps = self._get_element("Trap")
        self.maze = self._build()

    def _get_element(self, item_name: str) -> List[Tuple[int, int]]:
        """
        Parses 'InsideItems' of XML for parameterized items, organizing them in a list of tuples.
        :param item_name: str of XML tag inside 'InsideItems'
        :return: List[Tuple[int, int]] for arg element
        """
        item_list = []
        for wall in self.root.findall(f"InsideItems/{item_name}"):
            item_list.append((int(wall.find("Row").text) - 1, int(wall.find("Column").text) - 1))
        return item_list

    def _build(self, size: int = 17) -> List[List[str]]:
        """
        Constructs char list of the maze.
        :param size: rows/cols in maze. default = 17
        :return: List[List[str]] containing maze chars
        """
        maze = [[" " for _ in range(size)] for _ in range(size)]

        # walls
        for row, col in self.walls:
            maze[row][col] = "X"
        # traps
        for row, col in self.traps:
            maze[row][col] = "H"
        # outer boundaries
        for i in range(size):
            maze[i][0] = "X"
            maze[i][size - 1] = "X"
            maze[0][i] = "X"
            maze[size - 1][i] = "X"

        # start and escape
        maze[self.start[0]][self.start[1]] = "S"
        maze[self.escape[0]][self.escape[1]] = "E"

        return maze

    def outputXML(self, moves: str) -> str:
        """
        Generates an XML from the moves of the solver along with the rotations performed on the maze's
        quadrants.
        :param moves: string of moves generated by the solver
        :return: xml string of moves and rotations
        """
        actions = ET.Element("Actions")
        count = 1
        moves = moves.split("\n")

        for i in range(len(moves)-1):
            move = moves[i]
            next_move = moves[i+1]

            if move[0] == "r":
                rotate = ET.SubElement(actions, "Rotate")

                info = move.split(" ")
                ET.SubElement(rotate, "District").text = info[1]
                ET.SubElement(rotate, "Direction").text = info[2]
                count = 1
            elif move == next_move:
                count += 1
            else:
                step = ET.SubElement(actions, "Step")

                ET.SubElement(step, "Direction").text = move
                ET.SubElement(step, "CellNumber").text = str(count)

                count = 1
        return ET.tostring(actions, encoding='unicode')

    def __str__(self) -> str:
        return (f"Level:  {self.level}\n"
                f"Start:  ( {self.start[0] + 1} ; {self.start[1] + 1} )\n"
                f"Escape: ( {self.escape[0] + 1} ; {self.escape[1] + 1} )\n"
                f"Adjusted Start:  ( {self.start[0]} ; {self.start[1]} )\n"
                f"Adjusted Escape: ( {self.escape[0]} ; {self.escape[1]} )\n")
